use std::{collections::BTreeMap, ops::RangeBounds};

use anyhow::{anyhow, Result};
use itertools::Itertools;

use crate::util::nested::NestedVec;

/// Marks a split point within a section.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ObjSplit {
    pub unit: String,
    pub end: u32,
    pub align: Option<u32>,
    /// Whether this is a part of common BSS.
    pub common: bool,
    /// Generated, replaceable by user.
    pub autogenerated: bool,
}

/// Splits within a section.
#[derive(Debug, Clone, Default)]
pub struct ObjSplits {
    splits: BTreeMap<u32, Vec<ObjSplit>>,
}

impl ObjSplits {
    pub fn iter(&self) -> impl DoubleEndedIterator<Item = (u32, &ObjSplit)> {
        self.splits.iter().flat_map(|(addr, v)| v.iter().map(move |u| (*addr, u)))
    }

    pub fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item = (u32, &mut ObjSplit)> {
        self.splits.iter_mut().flat_map(|(addr, v)| v.iter_mut().map(move |u| (*addr, u)))
    }

    pub fn has_split_at(&self, address: u32) -> bool { self.splits.contains_key(&address) }

    /// Locate an existing split for the given address.
    pub fn for_address(&self, address: u32) -> Option<(u32, &ObjSplit)> {
        match self.for_range(..=address).next_back() {
            Some((addr, split)) if split.end == 0 || split.end > address => Some((addr, split)),
            _ => None,
        }
    }

    /// Locate existing splits within the given address range.
    pub fn for_range<R>(&self, range: R) -> impl DoubleEndedIterator<Item = (u32, &ObjSplit)>
    where R: RangeBounds<u32> {
        self.splits.range(range).flat_map(|(addr, v)| v.iter().map(move |u| (*addr, u)))
    }

    /// Locate existing splits within the given address range.
    pub fn for_range_mut<R>(
        &mut self,
        range: R,
    ) -> impl DoubleEndedIterator<Item = (u32, &mut ObjSplit)>
    where
        R: RangeBounds<u32>,
    {
        self.splits.range_mut(range).flat_map(|(addr, v)| v.iter_mut().map(move |u| (*addr, u)))
    }

    pub fn for_unit(&self, unit: &str) -> Result<Option<(u32, &ObjSplit)>> {
        self.splits
            .iter()
            .flat_map(|(addr, v)| v.iter().map(move |u| (*addr, u)))
            .filter(|&(_, split)| split.unit == unit)
            .at_most_one()
            .map_err(|_| anyhow!("Multiple splits for unit {}", unit))
    }

    pub fn push(&mut self, address: u32, split: ObjSplit) {
        self.splits.nested_push(address, split);
    }

    pub fn remove(&mut self, address: u32) -> Option<Vec<ObjSplit>> { self.splits.remove(&address) }
}
